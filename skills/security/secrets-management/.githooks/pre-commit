#!/usr/bin/env bash
################################################################################
# Git Pre-Commit Hook: Secret Scanning
#
# This hook prevents committing sensitive information to the repository by:
# 1. Scanning for hardcoded secrets, API keys, and credentials
# 2. Detecting common secret patterns (AWS keys, private keys, etc.)
# 3. Checking for suspicious file types (.env, credentials.json, etc.)
# 4. Using tools like TruffleHog, git-secrets, or gitleaks
#
# Installation:
#   1. Make this file executable: chmod +x .githooks/pre-commit
#   2. Copy to .git/hooks: cp .githooks/pre-commit .git/hooks/pre-commit
#   OR
#   3. Configure git hooks path: git config core.hooksPath .githooks
#
# Override (use with caution):
#   git commit --no-verify
################################################################################

set -euo pipefail

# ===== Configuration =====

RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Tools to use (in order of preference)
USE_GITLEAKS=true
USE_TRUFFLEHOG=true
USE_GIT_SECRETS=true
USE_PATTERN_MATCHING=true

# Allow bypass with environment variable (for emergencies)
if [[ "${SKIP_SECRET_SCAN:-false}" == "true" ]]; then
    echo -e "${YELLOW}⚠️  Secret scanning SKIPPED via SKIP_SECRET_SCAN=true${NC}"
    exit 0
fi

# ===== Functions =====

log_info() {
    echo -e "${BLUE}ℹ️  $*${NC}"
}

log_success() {
    echo -e "${GREEN}✅ $*${NC}"
}

log_warning() {
    echo -e "${YELLOW}⚠️  $*${NC}"
}

log_error() {
    echo -e "${RED}❌ $*${NC}"
}

check_tool() {
    local tool="$1"
    command -v "${tool}" >/dev/null 2>&1
}

# ===== Secret Detection Tools =====

scan_with_gitleaks() {
    if ! check_tool gitleaks; then
        log_warning "gitleaks not installed (install: brew install gitleaks)"
        return 0
    fi

    log_info "Scanning with gitleaks..."

    if gitleaks protect --staged --verbose --no-banner 2>&1; then
        log_success "gitleaks: No secrets detected"
        return 0
    else
        log_error "gitleaks: Secrets detected!"
        return 1
    fi
}

scan_with_trufflehog() {
    if ! check_tool trufflehog; then
        log_warning "trufflehog not installed (install: brew install trufflesecurity/trufflehog/trufflehog)"
        return 0
    fi

    log_info "Scanning with trufflehog..."

    # Get list of staged files
    local staged_files
    staged_files=$(git diff --cached --name-only --diff-filter=ACM)

    if [[ -z "$staged_files" ]]; then
        return 0
    fi

    # Scan staged files
    if echo "$staged_files" | xargs trufflehog filesystem --no-update --fail 2>&1; then
        log_success "trufflehog: No secrets detected"
        return 0
    else
        log_error "trufflehog: Secrets detected!"
        return 1
    fi
}

scan_with_git_secrets() {
    if ! check_tool git-secrets; then
        log_warning "git-secrets not installed (install: brew install git-secrets)"
        return 0
    fi

    log_info "Scanning with git-secrets..."

    # Initialize git-secrets if not already done
    if ! git secrets --list >/dev/null 2>&1; then
        log_info "Initializing git-secrets..."
        git secrets --install --force >/dev/null 2>&1 || true
        git secrets --register-aws >/dev/null 2>&1 || true
    fi

    if git secrets --pre_commit_hook; then
        log_success "git-secrets: No secrets detected"
        return 0
    else
        log_error "git-secrets: Secrets detected!"
        return 1
    fi
}

# ===== Pattern-Based Detection =====

scan_with_patterns() {
    log_info "Scanning with pattern matching..."

    local found_secrets=false

    # Get staged files
    local staged_files
    staged_files=$(git diff --cached --name-only --diff-filter=ACM)

    if [[ -z "$staged_files" ]]; then
        return 0
    fi

    # Patterns to detect (regex)
    local patterns=(
        # AWS
        'AKIA[0-9A-Z]{16}'                                    # AWS Access Key ID
        '(?i)aws_secret_access_key.*=.*[A-Za-z0-9/+=]{40}'   # AWS Secret Access Key

        # Private Keys
        '-----BEGIN (RSA |DSA |EC |OPENSSH |PGP )?PRIVATE KEY'

        # Generic API Keys
        '(?i)(api_key|apikey|api-key).*['\''"][0-9a-zA-Z]{32,}['\''"]'

        # GitHub Personal Access Token
        'ghp_[0-9a-zA-Z]{36}'
        'github_pat_[0-9a-zA-Z_]{82}'

        # Slack Token
        'xox[baprs]-[0-9]{10,12}-[0-9]{10,12}-[0-9a-zA-Z]{24,32}'

        # Google API Key
        'AIza[0-9A-Za-z\\-_]{35}'

        # JWT Token
        'eyJ[A-Za-z0-9_-]*\.eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*'

        # Generic Password
        '(?i)(password|passwd|pwd).*['\''"][^'\''"\s]{8,}['\''"]'

        # Database Connection String
        '(?i)(mongodb|mysql|postgres)://[^:]+:[^@]+@'

        # Stripe Key
        '(?i)(sk_live|pk_live)_[0-9a-zA-Z]{24,}'

        # Twilio
        'SK[0-9a-fA-F]{32}'

        # SendGrid
        'SG\.[0-9A-Za-z\\-_]{22}\.[0-9A-Za-z\\-_]{43}'
    )

    # Scan each staged file
    for file in $staged_files; do
        # Skip binary files
        if git diff --cached --numstat "$file" | grep -q '^-[[:space:]]-'; then
            continue
        fi

        # Get staged content
        local content
        content=$(git diff --cached "$file")

        # Check each pattern
        for pattern in "${patterns[@]}"; do
            if echo "$content" | grep -qP "$pattern"; then
                log_error "Potential secret found in ${file}"
                echo "$content" | grep -nP "$pattern" --color=always
                found_secrets=true
            fi
        done
    done

    if [[ "$found_secrets" == "true" ]]; then
        log_error "Pattern matching: Potential secrets detected!"
        return 1
    else
        log_success "Pattern matching: No secrets detected"
        return 0
    fi
}

# ===== Suspicious File Detection =====

check_suspicious_files() {
    log_info "Checking for suspicious files..."

    local suspicious_files=(
        '.env'
        '.env.local'
        '.env.production'
        'credentials.json'
        'service-account.json'
        'id_rsa'
        'id_dsa'
        '*.pem'
        '*.key'
        '*.p12'
        '*.pfx'
        'secrets.yml'
        'secrets.yaml'
    )

    local found_suspicious=false
    local staged_files
    staged_files=$(git diff --cached --name-only --diff-filter=ACM)

    for file in $staged_files; do
        for pattern in "${suspicious_files[@]}"; do
            if [[ "$file" == $pattern ]] || [[ "$(basename "$file")" == $pattern ]]; then
                log_error "Suspicious file staged: ${file}"
                found_suspicious=true
            fi
        done
    done

    if [[ "$found_suspicious" == "true" ]]; then
        log_error "Suspicious files detected!"
        log_warning "If these files are intentional, add them to .gitignore or use --no-verify"
        return 1
    else
        log_success "No suspicious files detected"
        return 0
    fi
}

# ===== Main Logic =====

main() {
    echo ""
    log_info "Running secret detection pre-commit hook..."
    echo ""

    local exit_code=0

    # Run all scanners
    if [[ "$USE_GITLEAKS" == "true" ]]; then
        scan_with_gitleaks || exit_code=1
    fi

    if [[ "$USE_TRUFFLEHOG" == "true" ]]; then
        scan_with_trufflehog || exit_code=1
    fi

    if [[ "$USE_GIT_SECRETS" == "true" ]]; then
        scan_with_git_secrets || exit_code=1
    fi

    if [[ "$USE_PATTERN_MATCHING" == "true" ]]; then
        scan_with_patterns || exit_code=1
    fi

    # Check for suspicious files
    check_suspicious_files || exit_code=1

    echo ""
    if [[ $exit_code -eq 0 ]]; then
        log_success "✅ All secret scans passed - commit allowed"
        echo ""
        return 0
    else
        log_error "🚫 Secret detection FAILED - commit blocked"
        echo ""
        echo "Possible actions:"
        echo "  1. Remove the secrets and use environment variables instead"
        echo "  2. Use a secrets manager (Vault, AWS Secrets Manager, etc.)"
        echo "  3. Add false positives to .gitignore or .gitleaksignore"
        echo "  4. Override (use with extreme caution): git commit --no-verify"
        echo ""
        return 1
    fi
}

main "$@"
